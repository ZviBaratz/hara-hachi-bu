#!/usr/bin/env bash
set -eu

# unified-power-ctl - Helper script for Unified Power Manager extension
# Handles privileged operations: setting battery thresholds, force-discharge
# Security: This script is intended to be run via polkit with root privileges.

EXIT_SUCCESS=0
EXIT_ERROR=1

# --- Validation Functions ---

# Log action to system journal
log_action() {
    logger -t unified-power-ctl "[ACTION] uid=${PKEXEC_UID:-?} $*"
}

# Validate that a sysfs path exists and is a regular file
validate_sysfs_path() {
    local path="$1"
    # Ensure the path is strictly within the power_supply directory
    # Allow alphanumeric and underscores for battery names
    if [[ ! "$path" =~ ^/sys/class/power_supply/[a-zA-Z0-9_]+/[a-z_]+$ ]]; then
        echo "Error: Forbidden path: $path" >&2
        exit "$EXIT_ERROR"
    fi
    [[ -f "$path" ]] || { echo "Error: Path does not exist or is not a file: $path" >&2; exit "$EXIT_ERROR"; }
}

# Sanitize input values - whitelist allowed characters
# Allows hyphens for mode values like "force-discharge"; battery names are
# further restricted by the command-parsing regex (alphanumeric + underscore only).
sanitize_input() {
    if [[ ! "$1" =~ ^[a-zA-Z0-9_\-]+$ ]]; then
        echo "Error: Invalid characters in input: $1" >&2
        exit "$EXIT_ERROR"
    fi
}

# Helper validation function
is_int() {
    [[ "$1" =~ ^(0|[1-9][0-9]*)$ ]]
}

validate_threshold() {
    if [ -z "${1:-}" ]; then
        echo "Error: Missing threshold value." >&2
        exit "$EXIT_ERROR"
    fi
    if ! is_int "$1"; then
        echo "Error: Threshold must be an integer." >&2
        exit "$EXIT_ERROR"
    fi
    if [ "$1" -lt 0 ] || [ "$1" -gt 100 ]; then
        echo "Error: Threshold must be between 0 and 100." >&2
        exit "$EXIT_ERROR"
    fi
}

# --- Command Parsing ---

TOOLCMD=${1:-}
# Sanitize all arguments
for arg in "$@"; do
    sanitize_input "$arg"
done

# Parse command format: <BATTERY_NAME>_<ACTION> or FORCE_DISCHARGE_<BATTERY_NAME>
if [[ "$TOOLCMD" =~ ^FORCE_DISCHARGE_([a-zA-Z0-9_]+)$ ]]; then
    BAT_NAME="${BASH_REMATCH[1]}"
    ACTION="FORCE_DISCHARGE"
elif [[ "$TOOLCMD" =~ ^(BAT[0-9]+)_(.+)$ ]]; then
    BAT_NAME="${BASH_REMATCH[1]}"
    ACTION="${BASH_REMATCH[2]}"
    # Defense-in-depth: validate ACTION is uppercase letters and underscores only
    if [[ ! "$ACTION" =~ ^[A-Z_]+$ ]]; then
        echo "Error: Invalid action format: $ACTION" >&2
        exit "$EXIT_ERROR"
    fi
else
    echo "Error: Unknown Command: '$TOOLCMD'" >&2
    exit "$EXIT_ERROR"
fi

# Define paths dynamically based on battery index
BAT_PATH="/sys/class/power_supply/${BAT_NAME}"

# Probe for supported end threshold file
if [ -f "${BAT_PATH}/charge_control_end_threshold" ]; then
    END_PATH="${BAT_PATH}/charge_control_end_threshold"
elif [ -f "${BAT_PATH}/stop_charge_thresh" ]; then
    END_PATH="${BAT_PATH}/stop_charge_thresh"
else
    # Default fallback (will fail validation if file doesn't exist)
    END_PATH="${BAT_PATH}/charge_control_end_threshold"
fi

# Probe for supported start threshold file
if [ -f "${BAT_PATH}/charge_control_start_threshold" ]; then
    START_PATH="${BAT_PATH}/charge_control_start_threshold"
elif [ -f "${BAT_PATH}/start_charge_thresh" ]; then
    START_PATH="${BAT_PATH}/start_charge_thresh"
else
    # Default fallback
    START_PATH="${BAT_PATH}/charge_control_start_threshold"
fi

FORCE_DISCHARGE_PATH="${BAT_PATH}/charge_behaviour"

case "$ACTION" in
    END)
        if [ "$#" -ne 2 ]; then echo "Error: END requires 1 argument" >&2; exit "$EXIT_ERROR"; fi
        END_VAL=$2
        validate_threshold "$END_VAL"
        validate_sysfs_path "$END_PATH"
        log_action "Setting ${BAT_NAME} end threshold to ${END_VAL}"
        echo "$END_VAL" >"$END_PATH"
        ;;
    START)
        if [ "$#" -ne 2 ]; then echo "Error: START requires 1 argument" >&2; exit "$EXIT_ERROR"; fi
        START_VAL=$2
        validate_threshold "$START_VAL"
        validate_sysfs_path "$START_PATH"
        log_action "Setting ${BAT_NAME} start threshold to ${START_VAL}"
        echo "$START_VAL" >"$START_PATH"
        ;;
    END_START)
        if [ "$#" -ne 3 ]; then echo "Error: END_START requires 2 arguments" >&2; exit "$EXIT_ERROR"; fi
        END_VAL=$2
        START_VAL=$3
        validate_threshold "$END_VAL"
        validate_threshold "$START_VAL"
        validate_sysfs_path "$END_PATH"
        validate_sysfs_path "$START_PATH"
        log_action "Setting ${BAT_NAME} thresholds: END=${END_VAL}, START=${START_VAL}"
        # Write END first, then START (safe order for increasing range)
        echo "$END_VAL" >"$END_PATH" && echo "$START_VAL" >"$START_PATH"
        ;;
    START_END)
        if [ "$#" -ne 3 ]; then echo "Error: START_END requires 2 arguments" >&2; exit "$EXIT_ERROR"; fi
        END_VAL=$2
        START_VAL=$3
        validate_threshold "$END_VAL"
        validate_threshold "$START_VAL"
        validate_sysfs_path "$START_PATH"
        validate_sysfs_path "$END_PATH"
        log_action "Setting ${BAT_NAME} thresholds: START=${START_VAL}, END=${END_VAL}"
        # Write START first, then END (safe order for decreasing range)
        echo "$START_VAL" >"$START_PATH" && echo "$END_VAL" >"$END_PATH"
        ;;
    FORCE_DISCHARGE)
        if [ "$#" -ne 2 ]; then echo "Error: FORCE_DISCHARGE requires 1 argument" >&2; exit "$EXIT_ERROR"; fi
        MODE=$2
        if [[ "$MODE" != "force-discharge" && "$MODE" != "auto" ]]; then
            echo "Error: Invalid force discharge mode. Allowed: 'force-discharge', 'auto'." >&2
            exit "$EXIT_ERROR"
        fi
        validate_sysfs_path "$FORCE_DISCHARGE_PATH"
        log_action "Setting ${BAT_NAME} force discharge to ${MODE}"
        echo "$MODE" >"$FORCE_DISCHARGE_PATH"
        ;;
    *)
        echo "Error: Unknown Action: '$ACTION' for $BAT_NAME" >&2
        exit "$EXIT_ERROR"
        ;;
esac

exit "$EXIT_SUCCESS"